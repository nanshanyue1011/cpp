### 1月2日 时空复杂度、数组

---

代码随想录1-3章 **时空复杂度、数组**

**力扣题目：**

==掌握双指针法以及其扩展产生的滑动窗口法==

#### [704.二分查找](https://leetcode.cn/problems/binary-search/)

要熟练掌握二分查找的算法，这几乎是十分常用的查找算法

#### [27.移除元素](https://leetcode.cn/problems/remove-element/)

#### [209.长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)

快慢指针的使用，使用一次循环和条件判断来完成两次循环的内容，将时间复杂度从O(N^2)降为O(N)，类似的还有滑动窗口问题。

#### [59.螺旋矩阵Ⅱ](https://leetcode.cn/problems/spiral-matrix-ii/)

> 注意：循环和递归需要找到什么在变化而什么形式上永远不变，根据不变量来编写代码

#### [977.有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/)

可以从数学的角度对本题进行思考，因为最小或最大的值在进行平方之后都有可能成为得到数组中最大的数值，所以我们需要使用头尾两个指针进行操作。

#### [1.两数之和](https://leetcode.cn/problems/two-sum/)

貌似很简单的一道题目，但是会有很多实现的方式

### 2023年1月13日 链表

---

代码随想录4章 **链表**

**力扣题目：**

==今天的题目需要多看多想==

#### [203. 移除链表元素](https://leetcode.cn/problems/remove-linked-list-elements/)

没什么好说的，入门题目

链表的一大问题就是操作当前节点必须要找前一个节点才能操作。这就造成了，头结点的尴尬，因为头结点没有前一个节点了。

**每次对应头结点的情况都要单独处理，所以使用虚拟头结点的技巧，就可以解决这个问题**。

#### [707. 设计链表 ](https://leetcode.cn/problems/design-linked-list/)

链表的设计是基础中的基础，其目的在于对链表进行增删改查，如果本题熟练掌握，则对于链表的操作可以证明已经炉火纯青的掌握

> 注意：在对链表操作的时候，要分清那个结点开始遍历，遍历多少结点，最终停止条件的时候cur指针指向的结点到底是哪一个

#### [206. 反转链表 ](https://leetcode.cn/problems/reverse-linked-list/)

反转链表的思想其实一点也不复杂，其纯粹的思想就是将每一个指针掉过头来反向链接，最重要的是如何处理头节点的问题以及如何保存转向之后剩余链表的信息。

两种实现方式，循环与递归，其实方法完全一致。

#### [19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

一道十分好的题目！两次单循环显然可以解决这个问题，这考验的是对于链表操作的基本功掌握如何。

一个绝妙的解法：使用双指针（拍案叫绝）

#### [160. 相交链表 ](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

由于链表的特性，如果链表两者相交，只能在交点后方全部一致，因为结点只能够有1个next指针。基本的想法是：选取最短的那个链表作为基础，将长链表与其长度对应的后端和短链表进行比较，如果有相同则相交，否则不相交

<img src="C:\Users\17372\AppData\Roaming\Typora\typora-user-images\image-20230113193236847.png" alt="image-20230113193236847" style="zoom:50%;" />

#### [142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)

判定是否有环？使用快慢指针。快指针每次走两格，慢指针每次走一格，若没有环，两者一定不会相遇，若两者相遇，一定有环，且慢指针此时第一次到达该位置。

如何判断环起点？设x为环前面的路径，y为慢指针被追上时候走的路径，z为环内剩余路径，有数学表达式：x+y+z+y = 2*（x+y）故有x = z。故我们此时将慢指针调至起始点，使快慢指针每次都走一格，再一次重合则为环的第一个结点

<img src="C:\Users\17372\AppData\Roaming\Typora\typora-user-images\image-20230113200634774.png" alt="image-20230113200634774" style="zoom:67%;" />

#### 总结

> - 链表的种类主要为：单链表，双链表，循环链表
> - 链表的存储方式：链表的节点在内存中是分散存储的，通过指针连在一起。
> - 链表是如何进行增删改查的。
> - 数组和链表在不同场景下的性能分析。

### 2023年1月15日 哈希表

---

代码随想录第5章 **哈希表**

因为大学阶段对于哈希散列的介绍较少，所以在这里详细介绍一下哈希表的内容。

#### 哈希表知识点

##### **哈希表**

**定义：**哈希表是根据关键码的值而进行直接访问的数据结构

直白来讲，数组也是一种哈希表。其中哈希表中的关键码就是数组的索引下标，然后通过下标直接访问数组中的元素

例如：查询一个名字是否在学生中，使用枚举的话时间复杂度为O(n)，如果使用哈希表只需要O(1)的时间复杂度。

将学生姓名映射到哈希表上涉及到哈希函数。

##### **哈希函数**

**定义：**通过hashCode把内容转化为数值，一般采用特定编码的方式，将其他的数据格式转化为不同的数值，这样就可以将学生名字映射成为哈希表上面的索引数字了。

为了不保证映射出来的数值都落在哈希表上，我们可以对数值进行取模的操作，但是会产生冲突的问题，也叫哈希碰撞。

##### **哈希碰撞**

**定义：**当不同的索引被映射到哈希表上的同一位置的时候，成为产生了哈希碰撞。

发生哈希碰撞有两种解决办法，拉链法和线性探测法

1. **拉链法**就是将映射成相同索引的内容以链表的方式链接在哈希表对应索引后面，这样只需要在对应索引后搜索即可。拉链法应该选择适当的哈希表大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多的时间。
2. **线性探测法**需要保证tableSize大于dataSize，需要依靠哈希表中的空位拉解决碰撞问题。冲突的位置放了a，就需要寻找下一个空位存放b，线性探测函数有很多种，在408的数据结构的学习中基本已经了解差不多了。

##### **常见的哈希结构**

* 数组
* 集合 set
* 映射 map

在C++中，set 和 map 分别提供以下三种数据结构，其底层实现以及优劣如下表所示：

| 集合               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
| ------------------ | -------- | -------- | ---------------- | ------------ | -------- | -------- |
| std::set           | 红黑树   | 有序     | 否               | 否           | O(log n) | O(log n) |
| std::multiset      | 红黑树   | 有序     | 是               | 否           | O(logn)  | O(logn)  |
| std::unordered_set | 哈希表   | 无序     | 否               | 否           | O(1)     | O(1)     |

std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。

当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。

那么再来看一下map ，在map 是一个key value 的数据结构，map中，对key是有限制，对value没有限制的，因为key的存储方式使用红黑树实现的。

虽然std::set、std::multiset 的底层实现是红黑树，不是哈希表，std::set、std::multiset 使用红黑树来索引和存储，不过给我们的使用方式，还是哈希法的使用方式，即key和value。所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法。 map也是一样的道理。

这里在说一下，一些C++的经典书籍上 例如STL源码剖析，说到了hash_set hash_map，这个与unordered_set，unordered_map又有什么关系呢？

实际上功能都是一样的， 但是unordered_set在C++11的时候被引入标准库了，而hash_set并没有，所以建议还是使用unordered_set比较好，这就好比一个是官方认证的，hash_set，hash_map 是C++11标准之前民间高手自发造的轮子。

> 总结：
>
> **当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法**。
>
> 但是哈希法也是**牺牲了空间换取了时间**，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。
>
> 如果在做面试题目的时候遇到需要判断一个元素是否出现过的场景也应该第一时间想到哈希法！

**力扣题目：**

哈希表在之前的编程使用中写的很少，要注意熟练度

#### [242. 有效的字母异位词 ](https://leetcode.cn/problems/valid-anagram/)

注意到，数组也是一个特殊的哈希表，可以将26个字母散列到一个26位的数组上，对于第一个字符串，每一次字符出现对应的字母个数+1，对于第二个字符串，每一次字符出现对应的字母个数-1，如果最终的结果都为0，证明互为异位，否则不是。

#### [349. 两个数组的交集](https://leetcode.cn/problems/intersection-of-two-arrays/)

这道题目，主要要学会使用一种哈希数据结构：unordered_set，这个数据结构可以解决很多类似的问题。

注意题目特意说明：**输出结果中的每个元素一定是唯一的，也就是说输出的结果的去重的， 同时可以不考虑输出结果的顺序**

这道题用暴力的解法时间复杂度是O(n^2)，那来看看使用哈希法进一步优化。

那么用数组来做哈希表也是不错的选择，

但是要注意，**使用数组来做哈希的题目，是因为题目都限制了数值的大小。**

而这道题目没有限制数值的大小，就无法使用数组来做哈希表了。

**而且如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。**

此时就要使用另一种结构体了，set ，关于set，C++ 给提供了如下三种可用的数据结构：

- std::set
- std::multiset
- std::unordered_set

std::set和std::multiset底层实现都是红黑树，std::unordered_set的底层实现是哈希表， 使用unordered_set 读写效率是最高的，并不需要对数据进行排序，而且还不要让数据重复，所以选择unordered_set。

这里有一些C++11标准中关于特性的用法，在C++语言的学习中处理。

#### [202. 快乐数 ](https://leetcode.cn/problems/happy-number/)

看似是一道数学问题，其实考虑逻辑的问题。

判定为1，这一点十分容易，用一个if语句就可以，只要sum=1，就肯定以后为1。

如何判定陷入循环？死循环？其实很简单，**如果出现了之前出现的sum，就可以判定出现之后的内容都是循环往复的。**

如何判断某个内容是否曾经出现过，使用哈希表时很好的选择。

#### [1. 两数之和](https://leetcode.cn/problems/two-sum/)

[这里我们使用两次循环O(N^2)实现过这一道题目](# 2023年1月2日)

也可以使用哈希map来做这道题目。

首先我在强调一下 **什么时候使用哈希法**，当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法。

本题呢，我就需要一个集合来存放我们遍历过的元素，然后在遍历数组的时候去询问这个集合，某元素是否遍历过，也就是 是否出现在这个集合。

那么我们就应该想到使用哈希法了。

因为本地，我们不仅要知道元素有没有遍历过，还有知道这个元素对应的下标，**需要使用 key value结构来存放，key来存元素，value来存下标，那么使用map正合适**。

再来看一下使用数组和set来做哈希法的局限。

- 数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。
- set是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x 和 y的下标。所以set 也不能用。

此时就要选择另一种数据结构：map ，map是一种key value的存储结构，可以用key保存数值，用value在保存数值所在的下标。

C++中map，有三种类型：

| 映射               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
| ------------------ | -------- | -------- | ---------------- | ------------ | -------- | -------- |
| std::map           | 红黑树   | key有序  | key不可重复      | key不可修改  | O(log n) | O(log n) |
| std::multimap      | 红黑树   | key有序  | key可重复        | key不可修改  | O(log n) | O(log n) |
| std::unordered_map | 哈希表   | key无序  | key不可重复      | key不可修改  | O(1)     | O(1)     |

std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。

同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。 更多哈希表的理论知识请看[关于哈希表，你该了解这些！ (opens new window)](https://www.programmercarl.com/哈希表理论基础.html)。

**这道题目中并不需要key有序，选择std::unordered_map 效率更高！** 使用其他语言的录友注意了解一下自己所用语言的数据结构就行。

接下来需要明确两点：

- **map用来做什么**
- **map中key和value分别表示什么**

map目的用来存放我们访问过的元素，因为遍历数组的时候，需要记录我们之前遍历过哪些元素和对应的下表，这样才能找到与当前元素相匹配的（也就是相加等于target）

接下来是map中key和value分别表示什么。

这道题 我们需要 给出一个元素，判断这个元素是否出现过，如果出现过，返回这个元素的下标。

那么判断元素是否出现，这个元素就要作为key，所以数组中的元素作为key，有key对应的就是value，value用来存下标。

所以 map中的存储结构为 {key：数据元素，value：数组元素对应的下表}。

在遍历数组的时候，只需要向map去查询是否有和目前遍历元素比配的数值，如果有，就找到的匹配对，如果没有，就把目前遍历的元素放进map中，因为map存放的就是我们访问过的元素。

#### [454. 四数相加 II](https://leetcode.cn/problems/4sum-ii/)

本题解题步骤：

1. 首先定义 一个unordered_map，key放a和b两数之和，value 放a和b两数之和出现的次数。
2. 遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中。
3. 定义int变量count，用来统计 a+b+c+d = 0 出现的次数。
4. 在遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就用count把map中key对应的value也就是出现次数统计出来。
5. 最后返回统计值 count 就可以了

#### [383. 赎金信 ](https://leetcode.cn/problems/ransom-note/)

和[242. 有效的字母异位词 ](https://leetcode.cn/problems/valid-anagram/)题目比较相似，只不过本题中要求赎金信中的字母要全部来自杂志，而杂志中的字母不必全部使用。了解了上一题，本题难度不大。

#### [15. 三数之和](https://leetcode.cn/problems/3sum/)

拿这个nums数组来举例，首先将数组排序，然后有一层for循环，i从下标0的地方开始，同时定一个下标left 定义在i+1的位置上，定义下标right 在数组结尾的位置上。

依然还是在数组中找到 abc 使得a + b +c =0，我们这里相当于 a = nums[i]，b = nums[left]，c = nums[right]。

接下来如何移动left 和right呢， 如果nums[i] + nums[left] + nums[right] > 0 就说明 此时三数之和大了，因为数组是排序后了，所以right下标就应该向左移动，这样才能让三数之和小一些。

如果 nums[i] + nums[left] + nums[right] < 0 说明 此时 三数之和小了，left 就向右移动，才能让三数之和大一些，直到left与right相遇为止。

说到去重，其实主要考虑三个数的去重。 a, b ,c, 对应的就是 nums[i]，nums[left]，nums[right]

a 如果重复了怎么办，a是nums里遍历的元素，那么应该直接跳过去。

但这里有一个问题，是判断 nums[i] 与 nums[i + 1]是否相同，还是判断 nums[i] 与 nums[i-1] 是否相同。

**如果我们的写法是 这样：**

```C++
if (nums[i] == nums[i + 1]) { // 去重操作
    continue;
}
```

**那就我们就把 三元组中出现重复元素的情况直接pass掉了。 **例如{-1, -1 ,2} 这组数据，当遍历到第一个-1 的时候，判断 下一个也是-1，那这组数据就pass了。**我们要做的是 不能有重复的三元组，但三元组内的元素是可以重复的！**

写本题的时候，去重的逻辑多加了 对right 和left 的去重，但这完全没有必要，因为在何时判断，最终进行的都将是right--与left++的操作。所以不如放在找到三元组之后再进行去重，找不到的情况下，即使重复也不会算入到最终的结果中，都会按照规定继续遍历。

**在获得到正确的三元组时，我们需要将两边的范围同时夹紧，否则去重后只移动一边绝对不会得到得0的三元组。**

#### [18. 四数之和](https://leetcode.cn/problems/4sum/)

与[15. 三数之和](https://leetcode.cn/problems/3sum/)十分类似，三数之和是将暴力解O(N^3)的算法通过双指针方式减到O(N^2)，而[18. 四数之和](https://leetcode.cn/problems/4sum/)是将暴力解的O(N^4)改为了O(N^3)

本题的难点在于如何通过的剪枝以及去重的操作。另外，target任意这一点十分恶心人。假设target=-10而数组为{-4，-3，-2，-1}，那么我们不能仅仅使用nums[i]>target就舍弃这种情况，剪枝的操作应该为：nums[i]>target && nums[i]>=0;

#### 总结

> **一般来说哈希表都是用来快速判断一个元素是否出现集合里**。
>
> 对于哈希表，要知道**哈希函数**和**哈希碰撞**在哈希表中的作用.
>
> 哈希函数是把传入的key映射到符号表的索引上。
>
> 哈希碰撞处理有多个key映射到相同索引上时的情景，处理碰撞的普遍方式是拉链法和线性探测法。
>
> 接下来是常见的三种哈希结构：
>
> - 数组
> - set（集合）
> - map（映射）
>
> 在C++语言中，set 和 map 都分别提供了三种数据结构，每种数据结构的底层实现和用途都有所不同
>
> **只有对这些数据结构的底层实现很熟悉，才能灵活使用，否则很容易写出效率低下的程序**。

### 2023年1月17日 字符串

---

代码随想录第6章 **字符串**

#### 字符串知识点

字符串是由若干字符组成的有限序列，可以理解为一个字符数组。

在C语言中，把一个字符串存入一个数组时候，也把结束符'\0'存入了数组，并以此作为该字符串是否结束的标志

C++语言中，提供了string类，string类会提供size接口，可以用来判断string类的字符串是否结束，不用'\0'判断字符串是否结束

vector`<char>`和string的区别是什么呢？

基本操作没有太多区别，但是string提供了更多的字符串处理的相关接口。例如string类重载了'+'但是vector没有

在处理字符串时，我们会有限定义一个string类型的变量

#### [344. 反转字符串](https://leetcode.cn/problems/reverse-string/)

要求原地修改输入的数组，可以将前后两个char进行交换

打基础的时候，不要太迷恋于库函数。例如本题目使用reverse就可以解决，但是对基础的训练完全没有任何的帮助，例如交换时可以使用swap函数，但自己写出交换的函数更好，要保证理解可以实现是相应的功能。

#### [541. 反转字符串 II ](https://leetcode.cn/problems/reverse-string-ii/)

**当需要固定规律一段一段去处理字符串的时候，要想想在在for循环的表达式上做做文章。**

#### [剑指 Offer 05. 替换空格 ](https://leetcode.cn/problems/ti-huan-kong-ge-lcof/)

如果想把这道题目做到极致，就不要只用额外的辅助空间了！

首先扩充数组到每个空格替换成"%20"之后的大小。

然后从后向前替换空格，也就是双指针法，过程如下：

i指向新长度的末尾，j指向旧长度的末尾。

从前向后填充就是O(n^2)的算法了，因为每次添加元素都要将添加元素之后的所有元素向后移动。

**其实很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作。**

这么做有两个好处：

1. 不用申请新数组。
2. 从后向前填充元素，避免了从前向后填充元素时，每次添加元素都要将添加元素之后的所有元素向后移动的问题。

#### [151. 反转字符串中的单词](https://leetcode.cn/problems/reverse-words-in-a-string/)

我想出的做法十分尿性（缝缝补补类型）

如果想：去掉所有的多余的空格，肯定先要去掉开始和结束的所有空格-->想到先用循环去掉开头的空格，翻转一次再去掉开头的空格（或者指针从结尾开始去掉结尾的空格也可以）

如果能够翻转单词，单词以空格结尾，我们先整体反转字符，然后每次遇到一个单词将单词整体反转，即可实现反转字符串中的单词

但是要注意的是内部条件的判断

1. 如何判断单词：使用计数器，当遇到空格且我们的计数器不为0时证明我们之前遇到的是一个完整的单词
2. 如何去掉多余的空格：当单词反转之后，我们必然遇到至少一个空格，此时只要多余的空格就要删除。注意erase操作时删除了指针还没有动，自动落到了下一位。==但是erase函数时间复杂度为O(N^2)==

   代码随想录给出的方式：双指针 空格也是元素，慢指针指向的是应该填入元素的位置，若这个位置是头部则直接填入元素，若这个位置为单词之间需要先预留一个空格的位置，再resize字符串即可得到去除空格之后的内容

#### [剑指 Offer 58 - II](https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)

与上一题类似，先全部逆置再部分逆置，简单

### 2023年1月19日 字符串KMP 双指针法训练

---

代码随想录第6章 **字符串**

重点是KMP算法的学习

#### KPM算法

##### 什么是KMP

KMP 算法（Knuth-Morris-Pratt 算法）是一个著名的字符串匹配算法，效率很高，但是确实有点复杂

##### KMP有什么用

KMP主要应用在字符串匹配上。

KMP的主要思想是==**当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。**==所以如何记录已经匹配的文本内容，是KMP的重点，也是next数组肩负的重任。

首先还是简单介绍一下 KMP 算法和暴力匹配算法的不同在哪里，难点在哪里，和动态规划有啥关系。

暴力的字符串匹配算法很容易写两个for循环，将txt与pat中的字母一个个比对，若不匹配，则pat字符退回到开始，txt字符退回到下一个字符的位置。显然其时间复杂度O(MN)。

<img src="https://pic4.zhimg.com/v2-817073ca77f6c75d234392f207a3c81b_b.webp" alt="动图" style="zoom:67%;" />

暴力法很蠢的原因在于，其明显多做了很多不必要的操作，因为c根本就不在子串中，却一步步匹配c。KMP 算法的不同之处在于，它会花费空间来记录一些信息，也就是我们说的next数组

code

又例如下面这个例子，txt = "aaaaaaab" pat = "aaab"，暴力解法还会和上面那个例子一样蠢蠢地回退指针 `i`，而 KMP 算法又会耍聪明，因为 KMP 算法知道字符 b 之前的字符 a 都是匹配的，所以每次只需要比较字符 b 是否被匹配就行了。==**KMP 算法永不回退 `txt` 的指针 `i`，不走回头路（不会重复扫描 `txt`），而是借助 `dp` 数组中储存的信息把 `pat` 移到正确的位置继续匹配**==，时间复杂度只需 O(N)

这个 `j` 不要理解为索引，它的含义更准确地说应该是**状态**（state），所以它会出现这个奇怪的位置，后文会详述

明白了 `dp` 数组只和 `pat` 有关，那么我们这样设计 KMP 算法就会比较漂亮：

```c++
public class KMP {
    private int[][] dp;
    private String pat;

    public KMP(String pat) {
        this.pat = pat;
        // 通过 pat 构建 dp 数组
        // 需要 O(M) 时间
    }

    public int search(String txt) {
        // 借助 dp 数组去匹配 txt
        // 需要 O(N) 时间
    }
}
```

这样，当我们需要用同一 `pat` 去匹配不同 `txt` 时，就不需要浪费时间构造 `dp` 数组了：

```c++
KMP kmp = new KMP("aaab");
int pos1 = kmp.search("aaacaaab"); //4
int pos2 = kmp.search("aaaaaaab"); //4
```

##### 什么是前缀表

**前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。**

前缀表的任务是当前位置匹配失败，找到之前已经匹配上的位置，再重新匹配，此也意味着在某个字符失配时，前缀表会告诉你下一步匹配中，模式串应该跳到哪个位置

什么是前缀表：**记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。**

##### 为什么一定要用前缀表

**下标5之前这部分的字符串（也就是字符串aabaaf）的最长相等的前缀 和 后缀字符串是 子字符串aa ，因为找到了最长相等的前缀和后缀，匹配失败的位置是后缀子串的后面，那么我们找到与其相同的前缀的后面重新匹配就可以了。**

##### 前缀表与next数组

很多KMP算法的时间都是使用next数组来做回退操作，那么next数组与前缀表有什么关系呢？

next数组就可以是前缀表，但是很多实现都是把前缀表统一减一（右移一位，初始位置为-1）之后作为next数组。

减1的操作是相当于状态量的变化）

##### 时间复杂度分析

其中n为文本串长度，m为模式串长度，因为在匹配的过程中，根据前缀表不断调整匹配的位置，可以看出匹配的过程是O(n)，之前还要单独生成next数组，时间复杂度是O(m)。所以整个KMP算法的时间复杂度是O(n+m)的。

暴力的解法显而易见是O(n × m)，所以**KMP在字符串匹配中极大地提高了搜索的效率**

##### 构造next数组

**构造next数组其实就是计算模式串s，前缀表的过程。** 主要有如下三步：

1. 初始化
2. 处理前后缀不相同的情况
3. 处理前后缀相同的情况

接下来我们详解一下。

1. 初始化：

定义两个指针i和j，j指向前缀末尾位置，i指向后缀末尾位置。

然后还要对next数组进行初始化赋值，如下：

```c++
int j = -1;
next[0] = j;
```

j 为什么要初始化为 -1呢，因为之前说过 前缀表要统一减一的操作仅仅是其中的一种实现，我们这里选择j初始化为-1，下文我还会给出j不初始化为-1的实现代码。

next[i] 表示 i（包括i）之前最长相等的前后缀长度（其实就是j）

所以初始化next[0] = j 。

2. 处理前后缀不相同的情况

因为j初始化为-1，那么i就从1开始，进行s[i] 与 s[j+1]的比较。

所以遍历模式串s的循环下标i 要从 1开始，代码如下：

```cpp
for (int i = 1; i < s.size(); i++) {
```

如果 s[i] 与 s[j+1]不相同，也就是遇到 前后缀末尾不相同的情况，就要向前回退。

怎么回退呢？

next[j]就是记录着j（包括j）之前的子串的相同前后缀的长度。

**==为什么？这个问题卡了很久==**

==因为匹配不相等的元素之前所有的元素都应该是被匹配上的，所以只要用子串前缀匹配到后缀就可以继续操作。==

那么 s[i] 与 s[j+1] 不相同，就要找 j+1前一个元素在next数组里的值（就是next[j]）。

所以，处理前后缀不相同的情况代码如下：

```cpp
while (j >= 0 && s[i] != s[j + 1]) { // 前后缀不相同了
    j = next[j]; // 向前回退
}
```

3. 处理前后缀相同的情况

如果 s[i] 与 s[j + 1] 相同，那么就同时向后移动i 和j 说明找到了相同的前后缀，同时还要将j（前缀的长度）赋给next[i], 因为next[i]要记录相同前后缀的长度。

代码如下：

```text
if (s[i] == s[j + 1]) { // 找到相同的前后缀
    j++;
}
next[i] = j;
```

最后整体构建next数组的函数代码如下：

```cpp
void getNext(int* next, const string& s){
    int j = -1;
    next[0] = j;
    for(int i = 1; i < s.size(); i++) { // 注意i从1开始
        while (j >= 0 && s[i] != s[j + 1]) { // 前后缀不相同了
            j = next[j]; // 向前回退
        }
        if (s[i] == s[j + 1]) { // 找到相同的前后缀
            j++;
        }
        next[i] = j; // 将j（前缀的长度）赋给next[i]
    }
}
```

代码构造next数组的逻辑流程动画如下：

![KMP精讲3](https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B23.gif)

> **关于指针回溯求next的理解**
> 每次求next【i】，可看作前缀与后缀的一次匹配，在该过程中就可以用上之前所求的next，若匹配失败，则像模式串与父串匹配一样，将指针移到next【j-1】上。
> 求next过程实际上是dp（动态规划），只与前一个状态有关：
> 若不匹配，一直往前退到0或匹配为止
> 若匹配，则将之前的结果传递：
> 因为之前的结果不为0时，前后缀有相等的部分，所以j所指的实际是与当前值相等的前缀，可视为将前缀从前面拖了过来，就不必将指针从前缀开始匹配了，所以之前的结果是可以传递的。

##### 使用next数组来做匹配

在文本串s里 找是否出现过模式串t。

定义两个下标j 指向模式串起始位置，i指向文本串起始位置。

那么j初始值依然为-1，为什么呢？ **依然因为next数组里记录的起始位置为-1。**

i就从0开始，遍历文本串，代码如下：

```cpp
for (int i = 0; i < s.size(); i++) 
```

接下来就是 s[i] 与 t[j + 1] （因为j从-1开始的） 进行比较。

如果 s[i] 与 t[j + 1] 不相同，j就要从next数组里寻找下一个匹配的位置。

代码如下：

```cpp
while(j >= 0 && s[i] != t[j + 1]) {
    j = next[j];
}
```

如果 s[i] 与 t[j + 1] 相同，那么i 和 j 同时向后移动， 代码如下：

```cpp
if (s[i] == t[j + 1]) {
    j++; // i的增加在for循环里
}
```

如何判断在文本串s里出现了模式串t呢，如果j指向了模式串t的末尾，那么就说明模式串t完全匹配文本串s里的某个子串了。

本题要在文本串字符串中找出模式串出现的第一个位置 (从0开始)，所以返回当前在文本串匹配模式串的位置i 减去 模式串的长度，就是文本串字符串中出现模式串的第一个位置。

代码如下：

```cpp
if (j == (t.size() - 1) ) {
    return (i - t.size() + 1);
}
```

##### 总结

[KMP 算法详解 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/83334559) 来自 `labuladong`的解释，从状态机的角度解释kmp算法中的问题，十分新颖和巧妙。

[算法学习笔记(13): KMP算法 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/105629613)来自 `pecco`的解释，没有说明next数组，使用的是PMT数组解决问题

#### [28. 找出字符串中第一个匹配项的下标](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/)

KPM算法在408数据结构的考察中很常见，不过其重点是在求next数组上面。

#### [459. 重复的子字符串](https://leetcode.cn/problems/repeated-substring-pattern/)

你妈的这是简单题？

1. 枚举法，很简单，在<=n/2的前缀串中遍历是否能多次重复
2. 我们将两个 sss 连在一起，并移除第一个和最后一个字符。如果 sss 是该字符串的子串，那么 sss 就满足题目要求。注意到我们证明的是如果 sss 满足题目要求，那么 sss 有这样的性质，而我们使用的方法却是如果 sss 有这样的性质，那么 sss 满足题目要求。因此，只证明了充分性是远远不够的，我们还需要证明必要性。而想要找到s字符串，显然可以使用KMP算法

**正确性证明**
一方面，如果长度为 $n$ 的字符串$s$是字符串 $t=s+s$的子串，并且 $s$在$t$中的起始位置不为$0$ 或$n$，那么$s$就满足题目的要求。证明过程如下：

我们设$s$在$t$中的起始位置为$i$，$i \in (0, n)$。也就是说，$t$中从位置$i$开始的$n$个连续的字符，恰好就是字符串$s$。那么我们有：

$$
s[0:n−1]=t[i:n+i−1]
$$

由于$t$是由两个$s$ 拼接而成的，我们可以将$t[i:n+i−1]$分成位置$n−1$左侧和右侧两部分：

$\left \{ \begin{aligned} s[0:n-i-1] &= t[i:n-1] \\ s[n-i:n-1] &= t[n:n+i-1] = t[0:i-1] \end{aligned} \right.$

每一部分都可以对应回$s$：

$\left \{ \begin{aligned} s[0:n-i-1] &= s[i:n-1] \\ s[n-i:n-1] &= s[0:i-1] \end{aligned} \right.$

这说明，$s$是一个「可旋转」的字符串：将$s$的前$i$个字符保持顺序，移动到$s$的末尾，得到的新字符串与$s$相同。也就是说，在模$n$的意义下，

$s[j]=s[j+i]$
对于任意的$i$恒成立。

> 「在模 $n$的意义下」可以理解为，所有的加法运算的结果都需要对$n$取模，使得结果保持在$[0,n)$中，这样加法就自带了「旋转」的效果。

如果我们不断地连写这个等式：

$s[j] = s[j+i] = s[j+2i] = s[j+3i] = \cdots$

那么所有满足$j_0 = j + k \cdot i$ 的位置 $j_0$  都有$s[j] = s[j_0]$，$i$和 $j_0$ 在模$i$的意义下等价。由于我们已经在模$n$的意义下讨论这个问题，因此$i$和$j_0$在模$\mathrm{gcd}(n,i)$的意义下等价，其中$\mathrm{gcd}$表示最大公约数。也就是说，字符串$S$中的两个位置如果在模 $\mathrm{gcd}(n,i)$的意义下等价，那么它们对应的字符必然是相同的。

由于$\mathrm{gcd}(n,i)$一定是$n$的约数，那么字符串$s$一定可以由其长度为$\mathrm{gcd}(n,i)$的前缀重复$\frac{n}{\mathrm{gcd}(n, i)} $次构成。

另一方面，如果$s$满足题目的要求，那么$s$包含若干个「部分」，$t=s+s$包含两倍数量的「部分」，因此$s$显然是$t$的子串，并且起始位置可以不为$0$或$n$：我们只需要选择$t$中第一个「部分」的起始位置即可。

综上所述，我们证明了：长度为$n$的字符串$s$是字符串$t=s+s$的子串，并且$s$在$t$中的起始位置不为$0$或$n$，当且仅当$s$满足题目的要求。

代码随想录第7章 **双指针法专题**

> 总结：

> 在[数组：就移除个元素很难么？ (opens new window)](https://programmercarl.com/0027.移除元素.html)中，原地移除数组上的元素，我们说到了数组上的元素，不能真正的删除，只能覆盖。
>
> 一些同学可能会写出如下代码（伪代码）：
>
> ```text
> for (int i = 0; i < array.size(); i++) {
>     if (array[i] == target) {
>         array.erase(i);
>     }
> }
> ```
>
> 这个代码看上去好像是O(n)的时间复杂度，其实是O(n^2)的时间复杂度，因为erase操作也是O(n)的操作。
>
> 所以此时使用双指针法才展现出效率的优势：**通过两个指针在一个for循环下完成两个for循环的工作。**

> 在[字符串：这道题目，使用库函数一行代码搞定 (opens new window)](https://programmercarl.com/0344.反转字符串.html)中讲解了反转字符串，注意这里强调要原地反转，要不然就失去了题目的意义。
>
> 使用双指针法，**定义两个指针（也可以说是索引下标），一个从字符串前面，一个从字符串后面，两个指针同时向中间移动，并交换元素。**，时间复杂度是O(n)。
>
> 在[替换空格 (opens new window)](https://programmercarl.com/剑指Offer05.替换空格.html)中介绍使用双指针填充字符串的方法，如果想把这道题目做到极致，就不要只用额外的辅助空间了！
>
> 思路就是**首先扩充数组到每个空格替换成"%20"之后的大小。然后双指针从后向前替换空格。**
>
> 有同学问了，为什么要从后向前填充，从前向后填充不行么？
>
> 从前向后填充就是O(n^2)的算法了，因为每次添加元素都要将添加元素之后的所有元素向后移动。
>
> **其实很多数组（字符串）填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作。**
>
> 那么在[字符串：花式反转还不够！ (opens new window)](https://programmercarl.com/0151.翻转字符串里的单词.html)中，我们使用双指针法，用O(n)的时间复杂度完成字符串删除类的操作，因为题目要删除冗余空格。
>
> **在删除冗余空格的过程中，如果不注意代码效率，很容易写成了O(n^2)的时间复杂度。其实使用双指针法O(n)就可以搞定。**
>
> **主要还是大家用erase用的比较随意，一定要注意for循环下用erase的情况，一般可以用双指针写效率更高！**

> 翻转链表是现场面试，白纸写代码的好题，考察了候选者对链表以及指针的熟悉程度，而且代码也不长，适合在白纸上写。
>
> 在[链表：听说过两天反转链表又写不出来了？ (opens new window)](https://programmercarl.com/0206.翻转链表.html)中，讲如何使用双指针法来翻转链表，**只需要改变链表的next指针的指向，直接将链表反转 ，而不用重新定义一个新的链表。**
>
> 思路还是很简单的，代码也不长，但是想在白纸上一次性写出bugfree的代码，并不是容易的事情。
>
> 在链表中求环，应该是双指针在链表里最经典的应用，在[链表：环找到了，那入口呢？ (opens new window)](https://programmercarl.com/0142.环形链表II.html)中讲解了如何通过双指针判断是否有环，而且还要找到环的入口。
>
> **使用快慢指针（双指针法），分别定义 fast 和 slow指针，从头结点出发，fast指针每次移动两个节点，slow指针每次移动一个节点，如果 fast 和 slow指针在途中相遇 ，说明这个链表有环。**
>
> 那么找到环的入口，其实需要点简单的数学推理，我在文章中把找环的入口清清楚楚的推理的一遍，如果对找环入口不够清楚的同学建议自己看一看[链表：环找到了，那入口呢？](https://programmercarl.com/0142.环形链表II.html)

> 在[哈希表：解决了两数之和，那么能解决三数之和么？ (opens new window)](https://programmercarl.com/0015.三数之和.html)中，讲到使用哈希法可以解决1.两数之和的问题
>
> 其实使用双指针也可以解决1.两数之和的问题，只不过1.两数之和求的是两个元素的下标，没法用双指针，如果改成求具体两个元素的数值就可以了，大家可以尝试用双指针做一个leetcode上两数之和的题目，就可以体会到我说的意思了。
>
> 使用了哈希法解决了两数之和，但是哈希法并不使用于三数之和！
>
> 使用哈希法的过程中要把符合条件的三元组放进vector中，然后在去去重，这样是非常费时的，很容易超时，也是三数之和通过率如此之低的根源所在。
>
> 去重的过程不好处理，有很多小细节，如果在面试中很难想到位。
>
> 时间复杂度可以做到O(n^2)，但还是比较费时的，因为不好做剪枝操作。
>
> 所以这道题目使用双指针法才是最为合适的，用双指针做这道题目才能就能真正体会到，**通过前后两个指针不算向中间逼近，在一个for循环下完成两个for循环的工作。**
>
> 只用双指针法时间复杂度为O(n^2)，但比哈希法的O(n^2)效率高得多，哈希法在使用两层for循环的时候，能做的剪枝操作很有限。
>
> 在[双指针法：一样的道理，能解决四数之和 (opens new window)](https://programmercarl.com/0018.四数之和.html)中，讲到了四数之和，其实思路是一样的，**在三数之和的基础上再套一层for循环，依然是使用双指针法。**
>
> 对于三数之和使用双指针法就是将原本暴力O(n^3)的解法，降为O(n^2)的解法，四数之和的双指针解法就是将原本暴力O(n^4)的解法，降为O(n^3)的解法。
>
> 同样的道理，五数之和，n数之和都是在这个基础上累加。

> 本文中一共介绍了leetcode上九道使用双指针解决问题的经典题目，除了链表一些题目一定要使用双指针，其他题目都是使用双指针来提高效率，一般是将O(n^2)的时间复杂度，降为$O(n)$。
>
> 建议大家可以把文中涉及到的题目在好好做一做，琢磨琢磨，基本对双指针法就不在话下了。

### 2023年1月20日 栈与队列

---

队列是先进先出，栈是先进后出。

如图所示：

![栈与队列理论1](https://img-blog.csdnimg.cn/20210104235346563.png)

那么我这里再列出四个关于栈的问题，大家可以思考一下。以下是以C++为例，使用其他编程语言的同学也对应思考一下，自己使用的编程语言里栈和队列是什么样的。

1. C++中stack 是容器么？
2. 我们使用的stack是属于哪个版本的STL？
3. 我们使用的STL中stack是如何实现的？
4. stack 提供迭代器来遍历stack空间么？

相信这四个问题并不那么好回答， 因为一些同学使用数据结构会停留在非常表面上的应用，稍稍往深一问，就会有好像懂，好像也不懂的感觉。

有的同学可能仅仅知道有栈和队列这么个数据结构，却不知道底层实现，也不清楚所使用栈和队列和STL是什么关系。

所以这里我再给大家扫一遍基础知识，

首先大家要知道 栈和队列是STL（C++标准库）里面的两个数据结构。

C++标准库是有多个版本的，要知道我们使用的STL是哪个版本，才能知道对应的栈和队列的实现原理。

那么来介绍一下，三个最为普遍的STL版本：

1. HP STL 其他版本的C++ STL，一般是以HP STL为蓝本实现出来的，HP STL是C++ STL的第一个实现版本，而且开放源代码。
2. P.J.Plauger STL 由P.J.Plauger参照HP STL实现出来的，被Visual C++编译器所采用，不是开源的。
3. SGI STL 由Silicon Graphics Computer Systems公司参照HP STL实现，被Linux的C++编译器GCC所采用，SGI STL是开源软件，源码可读性甚高。

接下来介绍的栈和队列也是SGI STL里面的数据结构， 知道了使用版本，才知道对应的底层实现。

来说一说栈，栈先进后出，如图所示：

![栈与队列理论2](https://img-blog.csdnimg.cn/20210104235434905.png)

栈提供push 和 pop 等等接口，所有元素必须符合先进后出规则，所以栈不提供走访功能，也不提供迭代器(iterator)。 不像是set 或者map 提供迭代器iterator来遍历所有元素。

**栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）。**

所以STL中栈往往不被归类为容器，而被归类为container adapter（容器适配器）。

那么问题来了，STL 中栈是用什么容器实现的？

从下图中可以看出，栈的内部结构，栈的底层实现可以是vector，deque，list 都是可以的， 主要就是数组和链表的底层实现。

![栈与队列理论3](https://img-blog.csdnimg.cn/20210104235459376.png)

**我们常用的SGI STL，如果没有指定底层实现的话，默认是以deque为缺省情况下栈的底层结构。**

deque是一个双向队列，只要封住一段，只开通另一端就可以实现栈的逻辑了。

**SGI STL中 队列底层实现缺省情况下一样使用deque实现的。**

我们也可以指定vector为栈的底层实现，初始化语句如下：

```cpp
std::stack<int, std::vector<int> > third;  // 使用vector为底层容器的栈
```

刚刚讲过栈的特性，对应的队列的情况是一样的。

队列中先进先出的数据结构，同样不允许有遍历行为，不提供迭代器, **SGI STL中队列一样是以deque为缺省情况下的底部结构。**

也可以指定list 为起底层实现，初始化queue的语句如下：

```cpp
std::queue<int, std::list<int>> third; // 定义以list为底层容器的队列
```

所以STL 队列也不被归类为容器，而被归类为container adapter（ 容器适配器）。

我这里讲的都是C++ 语言中的情况， 使用其他语言的同学也要思考栈与队列的底层实现问题， 不要对数据结构的使用浅尝辄止，而要深挖其内部原理，才能夯实基础。

#### [232. 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/)

使用两个栈实现队列先进先出，当入队操作的时候直接入栈，出队操作的时候要先将入队栈的内容转移到出队栈中，再出栈，但如果出队栈有内容就可以直接弹栈。

可以看出peek()的实现，直接复用了pop()， 要不然，==对stOut判空的逻辑又要重写一遍==。

#### [225. 用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/)

#### [20. 有效的括号](https://leetcode.cn/problems/valid-parentheses/)

一些写代码的技巧，以前都是在写每一个括号的判断，而且每次都要判断弹出的那个是否能匹配

换一种思路，我们在左括号的时候直接压入对应的括号，这样在遇到右括号的时候就可以直接判断是否与当前的括号相等来判断匹配，简化了判断的过程，使代码更加简洁。合理安排代码的结构也是一件需要在书写程序的时候考虑的问题。

#### [1047. 删除字符串中的所有相邻重复项](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/)

这道题目就像是我们玩过的游戏对对碰，如果相同的元素挨在一起就要消除。

可能我们在玩游戏的时候感觉理所当然应该消除，但程序又怎么知道该如何消除呢，特别是消除之后又有新的元素可能挨在一起。

此时游戏的后端逻辑就可以用一个栈来实现（我没有实际考察对对碰或者爱消除游戏的代码实现，仅从原理上进行推断）。

游戏开发可能使用栈结构，编程语言的一些功能实现也会使用栈结构，实现函数递归调用就需要栈，但不是每种编程语言都支持递归，例如：

**递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中**，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。

相信大家应该遇到过一种错误就是栈溢出，系统输出的异常是 `Segmentation fault`（当然不是所有的 `Segmentation fault` 都是栈溢出导致的） ，如果你使用了递归，就要想一想是不是无限递归了，那么系统调用栈就会溢出。

而且**在企业项目开发中，尽量不要使用递归**！在项目比较大的时候，由于参数多，全局变量等等，使用递归很容易判断不充分return的条件，非常容易无限递归（或者递归层级过深），**造成栈溢出错误（这种问题还不好排查!）**
